#ifndef PERIPH_PWM_H
#define PERIPH_PWM_H

#include "../../Core/Inc/tim.h"
#include "etl/function.h"

namespace Project::periph {

    /// PWM generation.
    /// @note requires: TIMx PWM generation mode, TIMx global interrupt
    struct PWM{
        using Callback = etl::Function<void(), void*>; ///< callback function class

        TIM_HandleTypeDef &htim; ///< tim handler generated by cubeMX
        uint32_t channel;        ///< TIM_CHANNEL_x
        Callback halfCB = {};
        Callback fullCB = {};

        /// default constructor
        constexpr PWM(TIM_HandleTypeDef &htim, uint32_t channel) : htim(htim), channel(channel) {}

        PWM(const PWM&) = delete; ///< disable copy constructor
        PWM(PWM&&) = delete;      ///< disable copy assignment

        PWM& operator=(const PWM&) = delete;  ///< disable move constructor
        PWM& operator=(PWM&&) = delete;       ///< disable move assignment

        /// set prescaler, period, pulse, half complete callback, and full complete callback
        /// @param prescaler set TIMx->PSC
        /// @param period set TIMx->ARR
        /// @param pulse set TIMx->CCRchannel
        /// @param halfFn half complete callback function pointer
        /// @param halfArg half complete callback function argument
        /// @param fullFn complete callback function pointer
        /// @param fullArg complete callback function argument
        template <typename HalfArg, typename FullArg>
        void init(uint16_t prescaler, uint32_t period, uint32_t pulse, 
                  void (*halfFn)(HalfArg*), HalfArg* halfArg, void (*fullFn)(FullArg*), FullArg* fullArg) {
            setPrescaler(prescaler);
            setPeriod(period);
            setPulse(pulse);
            setHalfCB(halfFn, halfArg);
            setFullCB(fullFn, fullArg);
        }

        /// set prescaler, period, pulse, half complete callback, and full complete callback
        /// @param prescaler set TIMx->PSC
        /// @param period set TIMx->ARR
        /// @param pulse set TIMx->CCRchannel
        /// @param halfFn half complete callback function pointer, default = null
        /// @param fullFn complete callback function pointer, default = null
        void init(uint16_t prescaler, uint32_t period, uint32_t pulse,
                  void (*incFn)() = nullptr, void (*decFn)() = nullptr) {
            init<void, void>(prescaler, period, pulse, (void(*)(void*)) incFn, nullptr, (void(*)(void*)) decFn, nullptr);
        }

        /// stop pwm and reset callback
        void deinit() {
            stop();
            setHalfCB(nullptr);
            setFullCB(nullptr);
        }

        /// set half callback
        /// @param fn half callback function pointer
        /// @param arg half callback function argument
        template <typename Arg>
        void setHalfCB(void (*fn)(Arg*), Arg* arg) { halfCB = { (void(*)(void*)) fn, (void*) arg }; }
        
        /// set half callback
        /// @param fn half callback function pointer
        void setHalfCB(void (*fn)()) { halfCB = { (void(*)(void*)) fn, nullptr }; }

        /// set full callback
        /// @param fn full callback function pointer
        /// @param arg full callback function argument
        template <typename Arg>
        void setFullCB(void (*fn)(Arg*), Arg* arg) { fullCB = { (void(*)(void*)) fn, (void*) arg }; }
        
        /// set full callback
        /// @param fn full callback function pointer
        void setFullCB(void (*fn)()) { fullCB = { (void(*)(void*)) fn, nullptr }; }

        /// start pwm interrupt
        void start() { HAL_TIM_PWM_Start_IT(&htim, channel); }

        /// stop pwm interrupt
        void stop() { HAL_TIM_PWM_Stop_IT(&htim, channel); }

        /// set TIMx->PSC
        void setPrescaler(uint16_t prescaler) const { htim.Instance->PSC = prescaler; }

        /// set TIMx->ARR
        void setPeriod(uint32_t period) const { htim.Instance->ARR = period; }

        /// set TIMx->CCRy
        void setPulse(uint32_t pulse) const {
            switch (channel) {
                case TIM_CHANNEL_1: htim.Instance->CCR1 = pulse; break;
                case TIM_CHANNEL_2: htim.Instance->CCR2 = pulse; break;
                case TIM_CHANNEL_3: htim.Instance->CCR3 = pulse; break;
                case TIM_CHANNEL_4: htim.Instance->CCR4 = pulse; break;
                default: break;
            }
        }

        /// get TIMx->PSC
        [[nodiscard]] uint16_t getPrescaler() const { return htim.Instance->PSC; }

        /// get TIMx->ARR
        [[nodiscard]] uint32_t getPeriod() const { return htim.Instance->ARR; }

        /// get TIMx->CCRy
        [[nodiscard]] uint32_t getPulse() const {
            switch (channel) {
                case TIM_CHANNEL_1: return htim.Instance->CCR1;
                case TIM_CHANNEL_2: return htim.Instance->CCR2;
                case TIM_CHANNEL_3: return htim.Instance->CCR3;
                case TIM_CHANNEL_4: return htim.Instance->CCR4;
                default: return 0;
            }
        }

    };

    /// PWM generation timer 3 channel 1
    inline PWM pwm3channel1 { htim3, TIM_CHANNEL_1 };

}

#endif //PERIPH_PWM_H
