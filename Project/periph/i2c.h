#ifndef PROJECT_PERIPH_I2C_H
#define PROJECT_PERIPH_I2C_H

#include "../../Core/Inc/i2c.h"
#include "etl/queue.h"
#include <cstring> // memcpy

namespace Project::Periph {

    /// I2C peripheral class
    /// @note requirements: event interrupt, tx DMA
    struct I2C {
        /// I2C transmit message class
        struct Msg {
            uint16_t deviceAddr, memAddr;
            uint32_t len;       ///< buffer length
            uint8_t *buf;       ///< pointer to buffer
            uint8_t bufTemp[4]; ///< pointer to temporary buffer (max. 4 bytes)
        };
        using Queue = etl::Queue<Msg, 128>; ///< I2C transmit queue type definition


        I2C_HandleTypeDef &hi2c; ///< I2C handler generated by cubeMX
        Queue txQueue;
        constexpr explicit I2C(I2C_HandleTypeDef &hi2c) : hi2c(hi2c), txQueue() {}

        void init()   { txQueue.init(); } ///< init tx queue
        void deinit() { txQueue.deinit(); } ///< deinit tx queue

        /// I2C transmit blocking
        /// @param deviceAddr device destination address
        /// @param memAddr memory address
        /// @param buf data buffer, either memory-fixed buffer or temporary buffer (max. 4 bytes)
        /// @param len buffer length
        /// @retval HAL_StatusTypeDef. see stm32fXxx_hal_def.h
        int writeBlocking(uint16_t deviceAddr,
                          uint16_t memAddr,
                          uint8_t *buf,
                          uint16_t len,
                          uint32_t timeout = HAL_MAX_DELAY) {
            while (hi2c.State != HAL_I2C_STATE_READY);
            return HAL_I2C_Mem_Write(&hi2c,
                                     deviceAddr,
                                     memAddr,
                                     1, buf, len,
                                     timeout);
        }

        /// I2C transmit non blocking
        /// @param deviceAddr device destination address
        /// @param memAddr memory address
        /// @param buf data buffer, either memory-fixed buffer or temporary buffer (max. 4 bytes)
        /// @param len buffer length
        /// @retval HAL_StatusTypeDef (see stm32fXxx_hal_def.h) or osStatus_t (cmsis_os2.h)
        int write(uint16_t deviceAddr, uint16_t memAddr, uint8_t *buf, uint16_t len) {
            if (hi2c.State == HAL_I2C_STATE_READY && hi2c.hdmatx->State == HAL_DMA_STATE_READY) {
                if (!txQueue) {
                    // transmit immediately if the queue is empty
                    return HAL_I2C_Mem_Write_DMA(&hi2c,
                                                 deviceAddr,
                                                 memAddr,
                                                 1, buf, len);
                }

                // transmit data from queue if any
                Msg msg = {};
                txQueue >> msg;
                uint8_t *_buf = msg.len > sizeof(msg.bufTemp) ? msg.buf : msg.bufTemp;
                HAL_I2C_Mem_Write_DMA(&hi2c,
                                      msg.deviceAddr,
                                      msg.memAddr,
                                      1, _buf, msg.len);
            }

            // i2c is busy, push to the queue, it will be handled in complete callback function
            Msg msg = {};
            msg.deviceAddr = deviceAddr;
            msg.memAddr = memAddr;
            msg.len = len;
            msg.buf = buf;
            if (len <= sizeof(msg.bufTemp)) memcpy(msg.bufTemp, buf, len);
            return txQueue.push(msg);
        }

        /// I2C transmit blocking
        /// @param deviceAddr device destination address
        /// @param memAddr memory address
        /// @param buf data buffer, either memory-fixed buffer or temporary buffer (max. 4 bytes)
        /// @param len buffer length
        /// @retval HAL_StatusTypeDef. see stm32fXxx_hal_def.h
        int readBlocking(uint16_t deviceAddr,
                         uint16_t memAddr,
                         uint8_t *buf,
                         uint16_t len,
                         uint32_t timeout = HAL_MAX_DELAY) {
            while (hi2c.State != HAL_I2C_STATE_READY);
            return HAL_I2C_Mem_Read(&hi2c,
                                     deviceAddr,
                                     memAddr,
                                     1, buf, len,
                                     timeout);
        }
    };

    inline I2C i2c2 { hi2c2 };

} // namespace Project


#endif // PROJECT_PERIPH_I2C_H