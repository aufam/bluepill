#ifndef PERIPH_UART_H
#define PERIPH_UART_H

#include "../../Core/Inc/usart.h"
#include "etl/array.h"
#include "etl/string.h"

namespace Project::Periph {

    /// UART peripheral class.
    /// @note requirements: global interrupt, rx DMA
    struct UART {
        /// callback function class
        struct RxCallback {
            typedef void (*Function)(void *, uint8_t *, size_t);
            Function fn;
            void *arg;
        };
        struct TxCallback {
            typedef void (*Function)(void *);
            Function fn;
            void *arg;
        };

        using Buffer = etl::Array<uint8_t , 64>; ///< UART rx buffer type definition

        UART_HandleTypeDef &huart; ///< UART handler generated by cubeMX
        Buffer rxBuffer;
        RxCallback rxCallback = {};
        TxCallback txCallback = {};
        constexpr explicit UART(UART_HandleTypeDef &huart) : huart(huart), rxBuffer{} {}

        /// set callback and start receive to idle DMA
        /// @param rxCBFn receive callback function pointer
        /// @param rxCBArg receive callback function argument
        /// @param txCBFn transmit callback function pointer
        /// @param txCBArg transmit callback function argument
        void init(RxCallback::Function rxCBFn = nullptr, void *rxCBArg = nullptr,
                  TxCallback::Function txCBFn = nullptr, void *txCBArg = nullptr)
        {
            setRxCallback(rxCBFn, rxCBArg);
            setTxCallback(txCBFn, txCBArg);
            HAL_UARTEx_ReceiveToIdle_DMA(&huart, rxBuffer.begin(), Buffer::size());
            __HAL_DMA_DISABLE_IT(huart.hdmarx, DMA_IT_HT);
        }

        /// disable receive DMA
        void deinit() { HAL_UART_DMAStop(&huart); }

        /// set rx callback
        /// @param rxCBFn receive callback function pointer
        /// @param rxCBArg receive callback function argument
        void setRxCallback(RxCallback::Function rxCBFn, void *rxCBArg = nullptr) {
            rxCallback.fn  = rxCBFn;
            rxCallback.arg = rxCBArg;
        }

        /// set tx callback
        /// @param txCBFn transmit callback function pointer
        /// @param txCBArg transmit callback function argument
        void setTxCallback(TxCallback::Function txCBFn, void *txCBArg = nullptr) {
            txCallback.fn  = txCBFn;
            txCallback.arg = txCBArg;
        }

        /// UART transmit blocking
        /// @param buf data buffer
        /// @param len buffer length
        /// @retval HAL_StatusTypeDef (see stm32fXxx_hal_def.h)
        int transmitBlocking(const uint8_t *buf, uint16_t len) {
            while (huart.gState != HAL_UART_STATE_READY);
            return HAL_UART_Transmit(&huart, (uint8_t *)buf, len, HAL_MAX_DELAY);
        }

        /// UART transmit non blocking
        /// @param buf data buffer
        /// @param len buffer length
        /// @retval HAL_StatusTypeDef (see stm32fXxx_hal_def.h)
        int transmit(const uint8_t *buf, uint16_t len) {
            return HAL_UART_Transmit_IT(&huart, (uint8_t *)buf, len);
        }

        void setBaudRate(uint32_t baud) {
            huart.Init.BaudRate = baud;
            HAL_UART_Init(&huart);
        }

        [[nodiscard]] uint32_t getBaudRate() const { return huart.Init.BaudRate; }

        /// write blocking operator
        template <size_t N>
        UART &operator <<(const etl::String<N>& str) { transmit(str.data(), str.len()); return *this; }
        UART &operator <<(const char *str) { transmitBlocking((uint8_t *) str, strlen(str)); return *this; }
    };

    /// UART 1, baud rate 9600
    inline UART uart1 { huart1 };

    /// UART 2, baud rate 9600
    inline UART uart2 { huart2 };

} // namespace Project


#endif // PERIPH_UART_H